

- 객체 지향 프로그래밍(Object Oriented Programming)과 new, delete

	- malloc/free, new/delete
		- malloc, free는 C에서 동적 메모리 할당(힙)을 위해 사용되던 함수
		- C++에서는 new와 delete가 추가됨으로서 더욱 쉽게 동적 메모리 할당 가능
		- 예시에서 malloc, free / new, delete는 같은 역할을 하며 굳이 쓰기 어려운 malloc를 쓸 이유가 이제 없음
		- 당연히 일반적인 지역변수는 delete가 불가능하고, 동적 할당된 포인터만 delete가 가능함
			-> heap이 아닌 stack의 메모리를 반환하는것은 애초에 말이 안됨
		++ 한가지 발견한 점 : new와 delete는 사실 연산자임. 그러므로 연산자 오버로딩이 가능함! 충분히 써먹을 여지가 있는 부분이라고 생각됨
			- new : 리턴 형태가 void*, 첫번째 인자로 size_t가 와야만 함
			- delete : 리턴 형태가 void, 첫번째 인자로 void*가 와야만 함
		++ soen.kr에서 추가로 배운 사항
			- delete는 null 포인터를 만나면 아무것도 안하도록 되어있어 안전함
			- new/delete 방식이 malloc/free방식보다 진보적이고 OOP에 적합
				1) malloc/free와 달리 new/delete는 라이브러리 제공 함수가 아닌 언어가 제공하는 연산자임 -> 변도의 헤더파일이 필요없고 프로그램이 커질 염려도 없으며, 사용자 정의 타입에 따라 오버로딩이 가능함
				2) malloc는 필요한 메모리 양을 바이트 단위로 지정하고 void*를 리턴하는 반면 new는 타입을 받고 해당 타입의 포인터를 리턴하므로 sizeof()와 캐스트가 필요없음 -> 실수의 가능성을 줄여줄 수 있을듯
				3) malloc은 메모리 할당만이 목적으로 초기값을 줄 수 없는 반면 new는 초기값까지 지정 가능 -> int* a = new int(10); 이런식
				4) new는 객체 할당시 자동으로 생성자가 호출되고 delete또한 마찬가지로 파괴자가 호출됨 -> new/delete가 더 좋은 결정적이 이유
			- realloc으로 크기를 바꿔 재할당 가능한 malloc과 달리 이러한 기능이 없고 새로 할당하여 복사하고 원래 메모리를 반환하는 과정을 직접 해주어야 함 -> 이 과정에서 매번 주소가 바뀜
				-> 때문에 객체 할당이 아니고 재할당이 자주 필요한 경우에는 malloc가 더 유리함
			- new/delete 와 malloc/free는 서로 짝을 맞추어야 하고 섞어 쓸수는 없음
				-> VC는 알아서 해주는 것 같지만 조심하자


	- new를 이용한 배열 할당
		- 기존의 배열을 만드는 [] 연산자 안에는 리터럴이나 상수 값이 들어와야 했었음
		- new를 이용하면 heap에 원하는만큼 공간을 할당이 가능해짐
		- 예시에는 malloc를 이용하여 똑같이 작동되도록 구현
		- 그냥 쉽게말해서 C의 동적배열 구현을 new로 바꾼거임
		- 동적 배열 삭제시에는 반드시 delete[] 연산자를 사용해야함
			-> VC 컴파일러는 delete로 해도 알아서 처리해주는것 같음(메모리 까보면 알아서 다 지움)

	※ Scope 스코프
		- C++에서 변수를 찾는 범위
		- {}로 묶인 코드 블록 내부에서부터 찾음



	- 실습 - 마이펫
		- 요구사항
			- 동물(struct Animal) 이라는 구조체를 정의해서 이름(char name[30]), 
			나이(int age), 체력(int health), 배부른 정도(int food), 깨끗한 정도의(int clean) 
			값을 가진다.

			- 처음에 동물 구조체의 포인터 배열(struct Animal* list[30])을 만들어서 
			사용자가 동물을 추가할 때 마다 하나씩 생성한다.

			- play 라는 함수를 만들어서 동물의 상태를 변경하고 
			show_stat 함수를 만들어서 지정하는 동물의 상태를 출력한다.

			- 1 턴이 지날 때 마다 동물의 상태를 변경한다.
		- 몇가지 문제점이 존재한다
			- play나 show_stat 등의 함수 호출을 위해서 일일히 인자를 전달하는 방법은 낭비
				-> 구조체 안에 함수를 만들어 animal->play()가 가능하면 편할텐데...
				-> 이런 방법이 있다면 멤버변수의 값들을 animal->을 전부 붙여가면서 할 필요도 없을텐데...
			- new animal로 새로운 동물을 생성했는데 create_animal을 호출하지 않는다면 치명적인 오류가 발생
				-> new로 생성함과 동시에 초기화되는 방법이 있으면 좋을텐데...
			- 다른 동물을 추가해서(bird, fish 등) 확장하려고 한다면 일일히 구조체를 추가해야 함으로 매우 불편함
		->> 이 모든것은 앞으로 class를 도입하면서 해결시킬 예정



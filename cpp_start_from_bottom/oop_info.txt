

- 객체 지향 프로그래밍(Object Oriented Programming)과 new, delete

	- malloc/free, new/delete
		- malloc, free는 C에서 동적 메모리 할당(힙)을 위해 사용되던 함수
		- C++에서는 new와 delete가 추가됨으로서 더욱 쉽게 동적 메모리 할당 가능
		- 예시에서 malloc, free / new, delete는 같은 역할을 하며 굳이 쓰기 어려운 malloc를 쓸 이유가 이제 없음
		- 당연히 일반적인 지역변수는 delete가 불가능하고, 동적 할당된 포인터만 delete가 가능함
			-> heap이 아닌 stack의 메모리를 반환하는것은 애초에 말이 안됨
		++ 한가지 발견한 점 : new와 delete는 사실 연산자임. 그러므로 연산자 오버로딩이 가능함! 충분히 써먹을 여지가 있는 부분이라고 생각됨
			- new : 리턴 형태가 void*, 첫번째 인자로 size_t가 와야만 함
			- delete : 리턴 형태가 void, 첫번째 인자로 void*가 와야만 함
		++ soen.kr에서 추가로 배운 사항
			- delete는 null 포인터를 만나면 아무것도 안하도록 되어있어 안전함
			- new/delete 방식이 malloc/free방식보다 진보적이고 OOP에 적합
				1) malloc/free와 달리 new/delete는 라이브러리 제공 함수가 아닌 언어가 제공하는 연산자임 -> 변도의 헤더파일이 필요없고 프로그램이 커질 염려도 없으며, 사용자 정의 타입에 따라 오버로딩이 가능함
				2) malloc는 필요한 메모리 양을 바이트 단위로 지정하고 void*를 리턴하는 반면 new는 타입을 받고 해당 타입의 포인터를 리턴하므로 sizeof()와 캐스트가 필요없음 -> 실수의 가능성을 줄여줄 수 있을듯
				3) malloc은 메모리 할당만이 목적으로 초기값을 줄 수 없는 반면 new는 초기값까지 지정 가능 -> int* a = new int(10); 이런식
				4) new는 객체 할당시 자동으로 생성자가 호출되고 delete또한 마찬가지로 파괴자가 호출됨 -> new/delete가 더 좋은 결정적이 이유
			- realloc으로 크기를 바꿔 재할당 가능한 malloc과 달리 이러한 기능이 없고 새로 할당하여 복사하고 원래 메모리를 반환하는 과정을 직접 해주어야 함 -> 이 과정에서 매번 주소가 바뀜
				-> 때문에 객체 할당이 아니고 재할당이 자주 필요한 경우에는 malloc가 더 유리함
			- new/delete 와 malloc/free는 서로 짝을 맞추어야 하고 섞어 쓸수는 없음
				-> VC는 알아서 해주는 것 같지만 조심하자


	- new를 이용한 배열 할당
		- 기존의 배열을 만드는 [] 연산자 안에는 리터럴이나 상수 값이 들어와야 했었음
		- new를 이용하면 heap에 원하는만큼 공간을 할당이 가능해짐
		- 예시에는 malloc를 이용하여 똑같이 작동되도록 구현
		- 그냥 쉽게말해서 C의 동적배열 구현을 new로 바꾼거임
		- 동적 배열 삭제시에는 반드시 delete[] 연산자를 사용해야함
			-> VC 컴파일러는 delete로 해도 알아서 처리해주는것 같음(메모리 까보면 알아서 다 지움)

	※ Scope 스코프
		- C++에서 변수를 찾는 범위
		- {}로 묶인 코드 블록 내부에서부터 찾음








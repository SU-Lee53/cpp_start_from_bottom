

- 참조(Reference)

1. 참조자의 도입

	- 최초 상황
		1) main에서 number = 5로 int 선언
		2) std::cout 으로 값 확인 결과 5가 출력
		3) ChangeVal의 인자로 &number가 넘어감
		4) ChangeVal에서 인자로 받아온 주소 내부의 값이 3으로 변경
		5) ChangeVal 리턴 후 다시 number 확인시 3으로 변경됨
	~ & : 이전까지 C에서 &는 주소값을 나타내는데 사용됨
		

	- 참조자의 도입
		1) 우선 a = 3으로 int 선언
		2) int&로 anotherA = a 로 선언됨 -> 참조자의 도입
		3) anotherA의 값을 5로 수정
		4) cout 결과 a와 anotherA의 값이 모두 5로 변경됨
		- 왜?? -> 메모리를 까보자
			- a의 주소값은 0x0000009C6657FBF4
			- anotherA의 주소값은 0x0000009C6657FBF4
			-> 둘은 같은 주소를 가리킨다.
		- 포인터로 선언하고 &a를 넣으면?
			- a의 주소값은 0x0000009C6657FBF4
			- anotherA의 주소값은 0x0000009C6657FBF4
			- 0x0000009C6657FBF4의 내부값은 03 00 00 00
			- pointA의 주소값은 0x0000009C6657FC38
			- pointA의 내부값은 f4 fb 57 66 9c 00 00 00(int*의 크기가 8바이트 이므로)
			- 내부에 값으로 a와 anotherA의 주소를 들고있는것이 확인됨!!!!!
				-> 인텔의 little-endian 표기법으로 인해 왼쪽부터 표기됨
		- 당연히 위의 주소값은 매 실행때마다 바뀐다

	~ & : C++에서의 &는 참조자의 역할을 하기도 한다!!
		- 가리키고자 하는 타입 뒤에 &를 붙여 선언

	~ 참조 Reference
		- 정말 말 그대로 "참조" 의 개념
		- 포인터와 유사하지만 엄연히 다른 개념으로 혼동하지 말아야함
		- 위 예시에서 anotherA는 a의 또다른 이름이 됨
		- 그러므로 anotherA는 단독으로 존재할수 없으며(값이 아님!!) 선언과 동시에 초기화 되어야함
		- 실제 주소를 찍어보면 &anotherA는 &a와 정확히 일치함!


	- 참조의 특징 1
		1) 새로운 _a = 0 을 선언
		2) anotherA가 이제 _a를 참조하도록 시도
		3) anotherA의 값도 0이 되었다? 새로운 값을 참조하게 된걸까?
		4) 어? 기존의 a도 0으로 바뀌었다??
		5) 주소도 찍어보니 여전히 anotherA는 a를 참조하고 있다!
		-> 한번 참조되면 다른변수가 참조되지 못함!
		-> anotherA = _a 는 a = _a와 동일! (a에다가 _a의 값을 넣은것)

	~ 참조(이어서)
		- 위에서 설명한 대로 참조는 선언과 동시에 초기화 되어야함
		- 또한 한번 초기화 되면 다른 변수를 참조할 수 없음
		

	- 포인터 vs 참조
		-> 포인터는 가리키는 대상을 자유롭게 변경가능
		-> 참조는 한번 가리키는 대상을 정하면 변경할 수 없음
		-> 예제 코드는 포인터가 가리키는 대상이 변경될 수 있음을 보여줌

	
	- 참조는 메모리상에 존재하지 않을 수 도 있다
		- 참조가 메모리 상에 공간을 할당받을 필요가 있을까?
			-> 일단은 NO
			-> ref_a를 컴파일러가 a로 바뀌서 컴파일해도 아무 문제가 없음
	
	- 참조가 항상 메모리상에 존재하지 않는것은 아니다 : 함수 인자로 참조를 받는 경우
		- 예제 코드에서 int ChangeVal(int &p)는 참조를 인자로 받고있음
		- 참조는 선언과 동시에 초기화되야하니까 int &p만 단독으로 있어도 됨?
			-> p는 함수가 호출될때 정의됨 
			-> ChangeVal(number)로 호출시 바로 p로 초기화되므로 전혀 문제가 없음!
		- 즉 함수 인자인 &p가 해당 함수 실행동안은 main의 number를 참조하게 됨
		- 그러면 함수의 메모리 공간 안에(아마도 스택) number의 주소를 저장해놔야함 -> 참조가 메모리에 존재
		- 그러므로 함수 호출시에 &number를 해줄 필요가 없음 (int& p = number와 같은의미임)


	- 참조의 참조 따위는 없다
		1) int x 선언
		2) int& y가 x를 참조
		3) int& z가 y를 참조
		4) x = 1 -> x, y, z가 모두 1
		5) y = 2 -> x, y, z가 모두 2
		6) z = 3 -> x, y, z가 모두 3
		- y가 참조니까 z는 int&&가 되어야 맞지않음?
			-> 해보면 오류가 뜬다 (C2440 : '초기화 중': 'int'에서 'int &&'(으)로 변환할 수 없습니다.)
			-> 애초에 말이 안되는 개념이고 C++ 문법상에서도 이를 금지하고 있음
		- 아니 그냥 포인터로 해도 똑같이 만들수 있는데 굳이?
			-> 매번 *와 &를 붙여가면서 하는것보다 간결하기도 하고 메모리 낭비도 적은 방법이므로 굳이 포인터로 할 이유가 없음
			-> std::cin이 아주 좋은 예시 
				-> scanf에서는 input을 일일히 &를 붙여가면서 주소를 받았음
				-> cin는 input을 참조로 받아오게 되면서 더이상 &를 붙이지 않아도 됨


	- 리터럴은 참조할 수 없다?
		- 리터럴? -> https://modoocode.com/33를 참고(나중에 다룰 것)
		- int& ref = 4 -> 오류가 뜬다 (C2440 : '초기화 중': 'int'에서 'int &'(으)로 변환할 수 없습니다.)
		- 리터럴은 수정하는것이 불가능하므로 참조가 불가능하다

	- 리터럴도 참조할 수 있긴하다
		- const int& ref = 4로 하니까 되긴 한다
		- 이를 상수 참조자라고 부른다

	
	- 참조의 배열은 불법
		- 배열 참조 시도시 발생하는 C2234 오류의 영문판에서는 진짜 illegal이라고 표기된다고 함
		- C++ 표준안 8.3.2/4 에서도 설명됨 : There shall be no references to references, no arrays of references, and no pointers to references
		- 왜?
			- 배열이 처리되는 방식을 생각해보면 됨
			- arr[2] -> arr은 arr[0]의 주솟값의 이름이고 arr[1]은 *(arr + 1)로 처리됨
			- 그러면 arr은 메모리에 실존하는것(arr[0]의 주소)
			- 그런데 참조는 메모리에 실존하지 않으므로 모순 발생 -> 불법
			- 그러니까 하지말라고 언어차원에서 막아놓은 것

	- 배열의 참조는 합법
		1) arr[3] = { 1, 2, 3 }으로 선언 후 초기화
		2) int(&ref)[3] = arr : arr[0] ~ arr[2]를 ref[0] ~ ref[2]가 참조함 -> 이때문에 배열을 참조하려면 크기를 명시해주어야 함


	- 참조를 리턴하는 함수(다음 이시간에)



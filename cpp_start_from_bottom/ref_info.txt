

- 참조(Reference)

1. 참조자의 도입

	- 최초 상황
		1) main에서 number = 5로 int 선언
		2) std::cout 으로 값 확인 결과 5가 출력
		3) ChangeVal의 인자로 &number가 넘어감
		4) ChangeVal에서 인자로 받아온 주소 내부의 값이 3으로 변경
		5) ChangeVal 리턴 후 다시 number 확인시 3으로 변경됨
	~ & : 이전까지 C에서 &는 주소값을 나타내는데 사용됨
		

	- 참조자의 도입
		1) 우선 a = 3으로 int 선언
		2) int&로 anotherA = a 로 선언됨 -> 참조자의 도입
		3) anotherA의 값을 5로 수정
		4) cout 결과 a와 anotherA의 값이 모두 5로 변경됨
		- 왜?? -> 메모리를 까보자
			- a의 주소값은 0x0000009C6657FBF4
			- anotherA의 주소값은 0x0000009C6657FBF4
			-> 둘은 같은 주소를 가리킨다.
		- 포인터로 선언하고 &a를 넣으면?
			- a의 주소값은 0x0000009C6657FBF4
			- anotherA의 주소값은 0x0000009C6657FBF4
			- 0x0000009C6657FBF4의 내부값은 03 00 00 00
			- pointA의 주소값은 0x0000009C6657FC38
			- pointA의 내부값은 f4 fb 57 66 9c 00 00 00(int*의 크기가 8바이트 이므로)
			- 내부에 값으로 a와 anotherA의 주소를 들고있는것이 확인됨!!!!!
				-> 인텔의 little-endian 표기법으로 인해 왼쪽부터 표기됨
		- 당연히 위의 주소값은 매 실행때마다 바뀐다

	~ & : C++에서의 &는 참조자의 역할을 하기도 한다!!
		- 가리키고자 하는 타입 뒤에 &를 붙여 선언

	~ 참조 Reference
		- 정말 말 그대로 "참조" 의 개념
		- 포인터와 유사하지만 엄연히 다른 개념으로 혼동하지 말아야함
		- 위 예시에서 anotherA는 a의 또다른 이름이 됨
		- 그러므로 anotherA는 단독으로 존재할수 없으며(값이 아님!!) 선언과 동시에 초기화 되어야함
		- 실제 주소를 찍어보면 &anotherA는 &a와 정확히 일치함!


	- 참조의 특징 1
		1) 새로운 _a = 0 을 선언
		2) anotherA가 이제 _a를 참조하도록 시도
		3) anotherA의 값도 0이 되었다? 새로운 값을 참조하게 된걸까?
		4) 어? 기존의 a도 0으로 바뀌었다??
		5) 주소도 찍어보니 여전히 anotherA는 a를 참조하고 있다!
		-> 한번 참조되면 다른변수가 참조되지 못함!
		-> anotherA = _a 는 a = _a와 동일! (a에다가 _a의 값을 넣은것)

	~ 참조(이어서)
		- 위에서 설명한 대로 참조는 선언과 동시에 초기화 되어야함
		- 또한 한번 초기화 되면 다른 변수를 참조할 수 없음
		

	- 포인터 vs 참조
		-> 포인터는 가리키는 대상을 자유롭게 변경가능
		-> 참조는 한번 가리키는 대상을 정하면 변경할 수 없음
		-> 예제 코드는 포인터가 가리키는 대상이 변경될 수 있음을 보여줌

	
	- 참조는 메모리상에 존재하지 않을 수 도 있다
		- 참조가 메모리 상에 공간을 할당받을 필요가 있을까?
			-> 일단은 NO
			-> ref_a를 컴파일러가 a로 바뀌서 컴파일해도 아무 문제가 없음
	
	- 참조가 항상 메모리상에 존재하지 않는것은 아니다 : 함수 인자로 참조를 받는 경우
		- 예제 코드에서 int ChangeVal(int &p)는 참조를 인자로 받고있음
		- 참조는 선언과 동시에 초기화되야하니까 int &p만 단독으로 있어도 됨?
			-> p는 함수가 호출될때 정의됨 
			-> ChangeVal(number)로 호출시 바로 p로 초기화되므로 전혀 문제가 없음!
		- 즉 함수 인자인 &p가 해당 함수 실행동안은 main의 number를 참조하게 됨
		- 그러면 함수의 메모리 공간 안에(아마도 스택) number의 주소를 저장해놔야함 -> 참조가 메모리에 존재
		- 그러므로 함수 호출시에 &number를 해줄 필요가 없음 (int& p = number와 같은의미임)


	- 참조의 참조 따위는 없다
		1) int x 선언
		2) int& y가 x를 참조
		3) int& z가 y를 참조
		4) x = 1 -> x, y, z가 모두 1
		5) y = 2 -> x, y, z가 모두 2
		6) z = 3 -> x, y, z가 모두 3
		- y가 참조니까 z는 int&&가 되어야 맞지않음?
			-> 해보면 오류가 뜬다 (C2440 : '초기화 중': 'int'에서 'int &&'(으)로 변환할 수 없습니다.)
			-> 애초에 말이 안되는 개념이고 C++ 문법상에서도 이를 금지하고 있음
		- 아니 그냥 포인터로 해도 똑같이 만들수 있는데 굳이?
			-> 매번 *와 &를 붙여가면서 하는것보다 간결하기도 하고 메모리 낭비도 적은 방법이므로 굳이 포인터로 할 이유가 없음
			-> std::cin이 아주 좋은 예시 
				-> scanf에서는 input을 일일히 &를 붙여가면서 주소를 받았음
				-> cin는 input을 참조로 받아오게 되면서 더이상 &를 붙이지 않아도 됨


	- 리터럴은 참조할 수 없다?
		- 리터럴? -> https://modoocode.com/33를 참고(나중에 다룰 것)
		- int& ref = 4 -> 오류가 뜬다 (C2440 : '초기화 중': 'int'에서 'int &'(으)로 변환할 수 없습니다.)
		- 리터럴은 수정하는것이 불가능하므로 참조가 불가능하다

	- 리터럴도 참조할 수 있긴하다
		- const int& ref = 4로 하니까 되긴 한다
		- 이를 상수 참조자라고 부른다

	
	- 참조의 배열은 불법
		- a와 b를 선언하고 arr로 배열을 만들어 참조하려고 하자 오류가 발생
		- 배열 참조 시도시 발생하는 C2234 오류의 영문판에서는 진짜 illegal이라고 표기됨
		- C++ 표준안 8.3.2/4 에서도 설명됨 : There shall be no references to references, no arrays of references, and no pointers to references
		- 왜?
			- 배열이 처리되는 방식을 생각해보면 됨
			- arr[2] -> arr은 arr[0]의 주솟값의 이름이고 arr[1]은 *(arr + 1)로 처리됨
			- 그러면 arr은 메모리에 실존하는것(arr[0]의 주소)
			- 그런데 참조는 메모리에 실존하지 않으므로 모순 발생 -> 불법
			- 그러니까 하지말라고 언어차원에서 막아놓은 것

	- 배열의 참조는 합법
		1) arr[3] = { 1, 2, 3 }으로 선언 후 초기화
		2) int(&ref)[3] = arr : arr[0] ~ arr[2]를 ref[0] ~ ref[2]가 참조함 -> 이때문에 배열을 참조하려면 크기를 명시해주어야 함

	- 쉽게 다시한번 요약하자면...
		- 처음부터 참조 그 자체로 배열을 만드는것은 불가능!
		- 이미 있는 배열을 참조하는것은 가능! 이때는 크기를 명시해서 초기화해주면 알아서 순서대로 참조가 된다


	- 지역변수의 참조를 리턴하는 함수
		- 예제로 작성된 코드는 모두의 코드에 작성된 코드와 같지만 vs컴파일러가 오류를 잡지않음...
		- vscode 를 이용하여 GCC 컴파일러로 테스트해보면 정상적으로 오류를 뱉음
		- int& functionA()에서 지역 변수의 참조를 리턴해주므로 함수 리턴시 지역변수 a가 소멸되면서 오류가 발생해야 정상임
		- 참조해야할 변수가 사라져버려 b 혼자서 남아있는 상황
		- 이를 Dangling Reference라고 부름
		- 아무튼 vs에서 오류가 안뜬다고 해서 그냥 써먹어서는 안된다...

	- 외부변수의 참조를 리턴하는 함수
		- 이번 functionB()는 인자로 받은 a를 리턴해주고 있음
		- 그러면 functionB()가 리턴하는 값은 함수 종료 후에도 살아있게 됨
		- 그러므로 int c는 b를 참조하는것과 같은 의미임
		- 왜 이런걸 쓰나요??
			-> 크기가 큰 구조체나 객체가 있을때 사용
			-> 해당 구조체(객체)를 리턴하면 전체 복사가 일어나므로 많은 시간이 소모됨
			-> 그러나 이 방법은 포인터 주소만 한번 복사해주면 되므로 매우 빠르게 끝남
			-> 결론: 참조 타입의 크기와 상관없이 한번의 주소값 복사로 전달이 끝나고 이는 매우 큰 장점임

	- 참조가 아닌 값을 리턴하는 함수를 참조자로 받기
		- int& c 에다가 functionC()의 값을 받아오려고 하면 오류가 발생
		- 오류: E0461 : 비const 참조에 대한 초기 값은 lvalue여야 합니다. -> lvalue와 rvalue에 대한 것은 나중에 다시 다룸
		- 간단히 말해서 위의 Dangling Reference 문제가 발생하기 때문에 불가능함
			-> functionC()의 a는 함수 종료시 소멸
			-> 이를 c가 참조? a는 소멸되고 없는데 당연히 불가능!

	- 위 문제의 해결법 : const 참조자
		- C++는 상수 참조로 리턴값을 받으면 해당 리턴값의 생명이 연장됨...
		- 연장되는 기간은 해당 참조가 살아있을때까지
		- 그런데 생각해보면 리터럴을 상수참조로 받는것과 유사한 개념으로 보임


	- 생각해보기
		- 레퍼런스가 메모리상에 반드시 존재해야 하는 경우?
			-> 함수의 인자로 받아왔거나 상수 레퍼런스
		- 반대로 메모리상에 존재할 필요가 없는 경우?
			-> 지역 변수 혹은 객체의 참조

